# -*- coding: utf-8 -*-
"""Backend MILP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zjw1RZyLRTwtJgxgXzzhq1jBal1VAxOW
"""


import ortools

from ortools.linear_solver import pywraplp
import pandas as pd

FILEPATH = "2131_revised_with_times.xlsx"

ALLOW_BACKLOG = True
lambda_OT  = 10
lambda_BL  = 1000
lambda_ALT = 5

# =========================
# LOAD DATA
# =========================
machines_df = pd.read_excel(FILEPATH, sheet_name="Machines", header=1).dropna(subset=["Machine"])
orders_df   = pd.read_excel(FILEPATH, sheet_name="Orders",   header=1).dropna(subset=["Order ID", "Part Code", "Quantity"])
routing_df  = pd.read_excel(FILEPATH, sheet_name="Routing_Long").dropna(subset=["Part Code", "Operation", "Machine", "Route Value"])
times_df    = pd.read_excel(FILEPATH, sheet_name="Times",    header=1).dropna(subset=["Part Code", "Operation", "Machine"])

# Normalize keys
for df, cols in [
    (machines_df, ["Machine"]),
    (orders_df,   ["Order ID", "Part Code"]),
    (routing_df,  ["Part Code", "Operation", "Machine"]),
    (times_df,    ["Part Code", "Operation", "Machine"]),
]:
    for c in cols:
        df[c] = df[c].astype(str).str.strip()

# Sets
I = machines_df["Machine"].tolist()
R = orders_df["Order ID"].tolist()

# Machine params
A = dict(zip(machines_df["Machine"], machines_df["A_min"]))
OT_max = dict(zip(machines_df["Machine"], machines_df["OT_max"]))

# Order params
part_of_order = dict(zip(orders_df["Order ID"], orders_df["Part Code"]))
q = dict(zip(orders_df["Order ID"], orders_df["Quantity"]))

# Merge routing + times
rt = routing_df.merge(times_df, how="left", on=["Part Code", "Operation", "Machine"])
rt = rt.dropna(subset=["unit_time_min_per_unit", "setup_time_min"])

# Build J = (r,k)
J = []
for r in R:
    part = part_of_order[r]
    ops = rt.loc[rt["Part Code"] == part, "Operation"].unique().tolist()
    for k in ops:
        J.append((r, k))
J = list(dict.fromkeys(J))

# Build a_ij, pi_ij, t_ij, s_ij
a, pi, t, s = {}, {}, {}, {}

has_pi_col = "pi_ij" in rt.columns

for (r, k) in J:
    part = part_of_order[r]
    rows = rt[(rt["Part Code"] == part) & (rt["Operation"] == k)]
    for _, row in rows.iterrows():
        i = row["Machine"]
        j = (r, k)

        # Eligibility
        a[(i, j)] = 1

        # Primary vs Alternative
        if has_pi_col:
            pi[(i, j)] = int(row["pi_ij"])   # 0 primary, 1 alt (already correct in your file)
        else:
            rv = float(row["Route Value"])    # 1 or 1.1
            pi[(i, j)] = 0 if rv == 1.0 else 1

        # Times
        t[(i, j)] = float(row["unit_time_min_per_unit"])
        s[(i, j)] = float(row["setup_time_min"])

# =========================
# SOLVER
# =========================
solver = pywraplp.Solver.CreateSolver("SCIP")
INF = solver.infinity()

# Variables
x = {(i, j): solver.BoolVar(f"x_{i}_{j[0]}_{j[1]}")
     for (i, j) in a}

U = {i: solver.NumVar(0, INF, f"U_{i}") for i in I}
OT = {i: solver.NumVar(0, OT_max[i], f"OT_{i}") for i in I}
U_avg = solver.NumVar(0, INF, "U_avg")
D_plus  = {i: solver.NumVar(0, INF, f"Dp_{i}") for i in I}
D_minus = {i: solver.NumVar(0, INF, f"Dm_{i}") for i in I}

if ALLOW_BACKLOG:
    y = {j: solver.BoolVar(f"y_{j[0]}_{j[1]}") for j in J}

# Constraints
for i in I:
    solver.Add(
        U[i] ==
        sum((t[(i, j)] * q[j[0]] + s[(i, j)]) * x[(i, j)]
            for j in J if (i, j) in a)
    )

for j in J:
    lhs = sum(x[(i, j)] for i in I if (i, j) in a)
    if ALLOW_BACKLOG:
        solver.Add(lhs + y[j] == 1)
    else:
        solver.Add(lhs == 1)

for i in I:
    solver.Add(U[i] <= A[i] + OT[i])

solver.Add(U_avg == sum(U[i] for i in I) / len(I))

for i in I:
    solver.Add(U[i] - U_avg == D_plus[i] - D_minus[i])

# Objective
obj = solver.Objective()
obj.SetMinimization()

for i in I:
    obj.SetCoefficient(D_plus[i], 1)
    obj.SetCoefficient(D_minus[i], 1)
    obj.SetCoefficient(OT[i], lambda_OT)

if ALLOW_BACKLOG:
    for j in J:
        obj.SetCoefficient(y[j], lambda_BL)

for (i, j) in x:
    obj.SetCoefficient(x[(i, j)], lambda_ALT * pi[(i, j)])

# Solve
status = solver.Solve()

if status == pywraplp.Solver.OPTIMAL:
    print("✅ Optimal schedule found\n")

    print("Assignments (order, operation → machine):")
    for (i, j), var in x.items():
        if var.solution_value() > 0.5:
            route = "PRIMARY" if pi[(i, j)] == 0 else "ALT"
            total_time = t[(i, j)] * q[j[0]] + s[(i, j)]
            print(f"  {j[0]}, {j[1]} → {i} [{route}] time={total_time:.2f} min")

    if ALLOW_BACKLOG:
        print("\nBacklogged ops (if any):")
        any_backlog = False
        for j in J:
            if y[j].solution_value() > 0.5:
                any_backlog = True
                print(f"  {j[0]}, {j[1]}")
        if not any_backlog:
            print("  none")

    print("\nMachine utilization:")
    for i in I:
        print(f"  {i}: U={U[i].solution_value():.2f} min | OT={OT[i].solution_value():.2f} min")

else:
    print("❌ No feasible solution. Common causes: missing Times rows, mismatched machine names, or too-tight A/OT limits.")

# =========================
# COLLECT RESULTS (backend-friendly)
# =========================

assignments = []
for (i, j), var in x.items():
    if var.solution_value() > 0.5:
        assignments.append({
            "order_id": j[0],
            "operation": j[1],
            "machine": i,
            "route_type": "PRIMARY" if pi[(i, j)] == 0 else "ALT",
            "unit_time_min_per_unit": t[(i, j)],
            "setup_time_min": s[(i, j)],
            "quantity": float(q[j[0]]),
            "total_time_min": float(t[(i, j)] * q[j[0]] + s[(i, j)])
        })

backlogged = []
if ALLOW_BACKLOG:
    for j in J:
        if y[j].solution_value() > 0.5:
            backlogged.append({"order_id": j[0], "operation": j[1]})

machine_summary = []
for i in I:
    machine_summary.append({
        "machine": i,
        "U_min": float(U[i].solution_value()),
        "OT_min": float(OT[i].solution_value()),
        "A_min": float(A[i]),
        "OT_max": float(OT_max[i]),
        "over_regular_time": bool(U[i].solution_value() > A[i] + 1e-6),
    })

# Optional: quick sanity prints
print("\n--- assignments (structured) ---")
print(assignments)

print("\n--- machine_summary ---")
print(machine_summary)

if ALLOW_BACKLOG:
    print("\n--- backlogged ---")
    print(backlogged)

import json

result_json = {
    "status": "OPTIMAL" if status == pywraplp.Solver.OPTIMAL else "NOT_OPTIMAL",
    "assignments": assignments,
    "machine_summary": machine_summary,
    "backlogged_operations": backlogged if ALLOW_BACKLOG else []
}

print("\n===== JSON OUTPUT =====")
print(json.dumps(result_json, indent=2))

with open("schedule_result.json", "w") as f:
    json.dump(result_json, f, indent=2)
